@using ClipLazor.Components;
@inject ISnackbar _snackbar
@inject IClipLazor Clipboard
@inject Services.SchedulePeriodPdf escalaPeriodoPdf
@inject Services.PDFSchedule pDFEscala
<MudDialog>
    <TitleContent>
        Visualização do período
    </TitleContent>
    <DialogContent>
        <MudStack Spacing="3" Class="mb-4">
            <MudCheckBox T="bool" @bind-Value="IsFilterActive" Label="Filtrar por Nome" Color="Color.Primary" />
            @if (IsFilterActive)
            {
                <MudAutocomplete T="string" Label="Nome do Responsável" @bind-Value="SelectedFilterName"
                                 SearchFunc="@SearchNames" Clearable="true" Variant="Variant.Outlined"
                                 AdornmentIcon="@Icons.Material.Filled.PersonSearch" />
            }
        </MudStack>

        @if (FilteredResponsavelInfos is not null && FilteredResponsavelInfos.Any())
        {
            <MudTable Items="@FilteredResponsavelInfos.OrderBy(x => x.Nome)" Height="300px" FixedHeader="true" Dense="true" Hover="true" Bordered="true" Striped="true">
                <HeaderContent>
                    <MudTh>Dia</MudTh>
                    <MudTh>Nome</MudTh>
                    <MudTh>Escala</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Dia">@context.dia.ToString("D02")</MudTd>
                    <MudTd DataLabel="Nome">@context.Nome</MudTd>
                    <MudTd DataLabel="Escala">@context.Escala</MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    <MudText>Nenhum responsável encontrado.</MudText>
                </NoRecordsContent>
                <LoadingContent>
                    <MudText>Carregando...</MudText>
                </LoadingContent>
            </MudTable>
        }
        else
        {
            <MudAlert Severity="Severity.Info" Class="mt-4">Nenhuma informação de responsável disponível para este período com o filtro atual.</MudAlert>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="OnSavePDF" Variant="Variant.Filled" Color="Color.Secondary" StartIcon="@Icons.Custom.FileFormats.FilePdf">Salvar (PDF)</MudButton>
        <MudButton OnClick="Cancel">Fechar</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;
    [Parameter]
    public (int Mes, int Ano) Date { get; set; }
    [Parameter]
    public List<(byte dia, string Nome, string Escala)> responsavelInfos { get; set; }

    public bool IsFilterActive { get; set; } = false;
    public string SelectedFilterName { get; set; }

    // Propriedade computada para a lista filtrada
    private IEnumerable<(byte dia, string Nome, string Escala)> FilteredResponsavelInfos
    {
        get
        {
            if (!IsFilterActive || string.IsNullOrWhiteSpace(SelectedFilterName))
            {
                return responsavelInfos ?? new List<(byte, string, string)>();
            }
            return responsavelInfos?.Where(info => info.Nome.Contains(SelectedFilterName, StringComparison.OrdinalIgnoreCase))
                   ?? new List<(byte, string, string)>();
        }
    }

    // Método para buscar nomes para o MudAutocomplete
    private async Task<IEnumerable<string>> SearchNames(string? value, CancellationToken cancellationToken)
    {
        // Se a lista ou o valor de busca estiver vazio, retorna todos os nomes únicos
        if (responsavelInfos == null || string.IsNullOrWhiteSpace(value))
            return await Task.FromResult(responsavelInfos?.Select(x => x.Nome).Distinct().OrderBy(x => x) ?? Enumerable.Empty<string>());

        // Filtra os nomes baseados no valor de busca
        return await Task.FromResult(responsavelInfos
            .Select(x => x.Nome)
            .Distinct()
            .Where(x => x.Contains(value, StringComparison.OrdinalIgnoreCase))
            .OrderBy(x => x));
    }

    public async Task OnSavePDF()
    {


        if (FilteredResponsavelInfos != null && FilteredResponsavelInfos.Any())
        {
            var groupByDia = FilteredResponsavelInfos.GroupBy((e) => e.dia);

            var resultado = from e in groupByDia
                            select (
                                new DateOnly(Date.Ano, Date.Mes, e.Key),
                                from item in e
                                select (
                                item.Nome,
                                item.Escala
                            )
            );


            using var streamSource = escalaPeriodoPdf.GeneratePDF(resultado);

            await pDFEscala.GeneratePDF(streamSource,"escala-periodo.pdf");
        }
        else
        {
        }


    }


    private void Cancel() => MudDialog.Cancel();
    public static List<(byte dia, string Nome, string Escala)> SelectByPeriodo(IEnumerable<View.ScheduleTypeView> escalaTipo, int diaInicial, int diaFinal)
    {
        var query =
        from escalaTipoCur in escalaTipo

            // Nível 2: 'Zip' os períodos (dias e nomes) para cada escala
        from periodo in escalaTipoCur.Dates().Zip(escalaTipoCur.Names)

            // Nível 3: 'Zip' os dias e nomes dentro de cada período
        from diaNome in periodo.First.Zip(periodo.Second)

            // Filtragem: Apenas os dias no período
        where diaNome.First >= diaInicial && diaNome.First <= diaFinal

        // Projeção: Cria a tupla final com nomes descritivos
        select (Dia: diaNome.First, Nome: diaNome.Second, Escala: escalaTipoCur.Name);

        // Ordenação e ToList
        var namesList = query
            .OrderBy(r => r.Dia)
            .ToList();

        return namesList;
    }
}